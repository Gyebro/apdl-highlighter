<!DOCTYPE html><html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <meta name="date" content="2017-07-14 18:41:03-04:00"><title>14.11.&nbsp;Newton-Raphson Procedure</title><link rel="stylesheet" type="text/css" href="basic.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="ans_thry.html" title="Mechanical APDL Theory Reference"><link rel="up" href="thy_tool.html" title="Chapter&nbsp;14:&nbsp;Analysis Tools"><link rel="prev" href="thy_toolrom.html" title="14.10.&nbsp;Reduced Order Modeling of Coupled Domains"><link rel="next" href="thy_tool11.html" title="14.12.&nbsp;Constraint Equations"><script type="text/javascript"><!--
function toggleElementDisplay (id) {
  var elem = document.getElementById(id);
  if (elem.style.display != "block") {
    elem.style.display = "block";
  } else {
    elem.style.display = "none";
  }
}
//--></script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" title="14.11.&nbsp;Newton-Raphson Procedure"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kKdAfeelmm"></a>14.11.&nbsp;Newton-Raphson Procedure</h2></div></div></div><a class="indexterm" name="d0e70297"></a><div class="highlights"><p>The following Newton-Raphson procedure topics are available:</p><ul><li><a href="thy_tool10.html#eltoverview2" title="14.11.1.&nbsp;Overview">Overview</a></li><li><a href="thy_tool10.html#eltconverg" title="14.11.2.&nbsp;Convergence">Convergence</a></li><li><a href="thy_tool10.html#eltpredictor" title="14.11.3.&nbsp;Predictor">Predictor</a></li><li><a href="thy_tool10.html#eltadaptive" title="14.11.4.&nbsp;Adaptive Descent">Adaptive Descent</a></li><li><a href="thy_tool10.html#eltlinesearc" title="14.11.5.&nbsp;Line Search">Line Search</a></li><li><a href="thy_tool10.html#eltarclength" title="14.11.6.&nbsp;Arc-Length Method">Arc-Length Method</a></li></ul></div><div class="sect2" title="14.11.1.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="eltoverview2"></a>14.11.1.&nbsp;Overview</h3></div></div></div><a class="indexterm" name="d0e70306"></a><a class="indexterm" name="d0e70309"></a><a class="indexterm" name="d0e70314"></a><a class="indexterm" name="d0e70317"></a><p>The finite element discretization process yields a set of simultaneous
equations: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq1overviewnov2101"></a><div><img src="graphics/thyeq1overviewnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;152)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>[K] = coefficient matrix </td></tr><tr><td>{u} = vector of unknown DOF (degree of freedom) values </td></tr><tr><td>{F<sup>a</sup>} = vector of applied loads </td></tr></table><p>
</p><p>If the coefficient matrix [K] is itself a function of the unknown
DOF values (or their derivatives) then <a class="xref" href="thy_tool10.html#thyeq1overviewnov2101" title="(14&#8211;152)">Equation&nbsp;14&#8211;152</a> is a nonlinear equation. The Newton-Raphson
method is an iterative process of solving the nonlinear equations
and can be written as (Bathe(<a class="xref" href="thy_biblio.html#aYwgf26dmlg" title="Finite Element Procedures">[2]</a>)): </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq2overviewnov2101"></a><div><img src="graphics/thyeq2overviewnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;153)</b></p></td></tr></table><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq3overviewnov2101"></a><div><img src="graphics/thyeq3overviewnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;154)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>

<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqde787dfe-382d-423d-9015-1d7f7fea05f5.svg"></span> = Jacobian matrix (tangent matrix)</td></tr><tr><td> i = subscript representing the current equilibrium iteration </td></tr><tr><td>

<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqa6ad9362-6bde-47bc-b59d-a08d9f33210a.svg"></span> = vector of restoring loads corresponding
to the element internal loads </td></tr></table><p>
</p><p>Both 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq6c0fa72d-cbcd-42db-86ac-3bd2ffd4850a.svg"></span> and 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq9858e4da-8f75-4a77-83ab-57f906619bdd.svg"></span> are evaluated based on the values
given by {u<sub>i</sub>}. The right-hand side of <a class="xref" href="thy_tool10.html#thyeq2overviewnov2101" title="(14&#8211;153)">Equation&nbsp;14&#8211;153</a> is the residual or out-of-balance
load vector; i.e., the amount the system is out of equilibrium. A
single solution iteration is depicted graphically in <a class="xref" href="thy_tool10.html#Ecqre110leaf" title="Figure&nbsp;14.9:&nbsp;&nbsp;Newton-Raphson Solution - One Iteration">Figure&nbsp;14.9:&nbsp;Newton-Raphson Solution - One Iteration</a> for a one DOF model. In a structural analysis, 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqd79aed39-038e-4450-8967-c652d70babc7.svg"></span> is the tangent stiffness matrix, {u<sub>i</sub>} is the displacement vector and 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq73d45b77-03b7-4eee-b8a9-2f7f99d899aa.svg"></span> is the restoring force vector calculated
from the element stresses. In a thermal analysis, 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqfb41c941-265e-44d6-87f4-5444aada1562.svg"></span> is the conductivity matrix, {u<sub>i</sub>} is the temperature vector and 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqc4a7f989-9538-4e3b-a374-1b4ca4c3ae53.svg"></span> is the resisting load vector calculated
from the element heat flows. In an electromagnetic analysis, 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq0f5354ab-5e90-4014-bb90-a9f0f3c6802a.svg"></span> is the Dirichlet matrix, {u<sub>i</sub>} is the magnetic potential vector, and 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq97b24569-9e3a-42bf-b6d6-1f031f9f025d.svg"></span> is the resisting load vector calculated
from element magnetic fluxes. In a transient analysis, 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqd078ca07-68d2-4ae9-adee-52e01504825a.svg"></span> is the effective coefficient matrix and 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqe087779e-91a5-44ed-857a-f733f280f0fb.svg"></span> is the effective applied load vector which
includes the inertia and damping effects. </p><p>As seen in the following figures, more than one Newton-Raphson
iteration is needed to obtain a converged solution. The general algorithm
proceeds as follows: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Assume {u<sub>0</sub>}. {u<sub>0</sub>} is usually the converged solution from the previous time step.
On the first time step, {u<sub>0</sub>} = {0}. </p></li><li class="listitem"><p>Compute the updated tangent matrix 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq5e7d16c1-ecd8-4698-b1e2-0efbdd3cd6fb.svg"></span> and the restoring load 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq17f8b27d-dc8b-4ea9-b643-4f368d178489.svg"></span> from configuration {u<sub>i</sub>}. </p></li><li class="listitem"><p>Calculate {&#916;u<sub>i</sub>} from <a class="xref" href="thy_tool10.html#thyeq2overviewnov2101" title="(14&#8211;153)">Equation&nbsp;14&#8211;153</a>. </p></li><li class="listitem"><p>Add {&#916;u<sub>i</sub>} to {u<sub>i</sub>} in order to obtain the next approximation {u<sub>i + 1</sub>} (<a class="xref" href="thy_tool10.html#thyeq3overviewnov2101" title="(14&#8211;154)">Equation&nbsp;14&#8211;154</a>). </p></li><li class="listitem"><p>Repeat steps 2 to 4 until convergence is obtained. </p></li></ol></div><div class="figure"><a name="Ecqre110leaf"></a><p class="title"><b>Figure&nbsp;14.9:&nbsp;&nbsp;Newton-Raphson Solution - One Iteration</b></p><div class="figure-contents"><div><img src="graphics/gthy15-253.svg" alt="Newton-Raphson Solution - One Iteration"></div></div></div><br class="figure-break"><p>
<a class="xref" href="thy_tool10.html#SH41g3dcmlg" title="Figure&nbsp;14.10:&nbsp;&nbsp;Newton-Raphson Solution - Next Iteration">Figure&nbsp;14.10:&nbsp;Newton-Raphson Solution - Next Iteration</a> shows the solution of the next
iteration (i + 1) of the example from <a class="xref" href="thy_tool10.html#Ecqre110leaf" title="Figure&nbsp;14.9:&nbsp;&nbsp;Newton-Raphson Solution - One Iteration">Figure&nbsp;14.9:&nbsp;Newton-Raphson Solution - One Iteration</a>. The subsequent iterations would proceed in a similar manner. </p><p>The solution obtained at the end of the iteration process would
correspond to load level {F<sup>a</sup>}. The final
converged solution would be in equilibrium, such that the restoring
load vector 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq0efba843-36f8-4165-a48a-d689453d0372.svg"></span> (computed from the current stress
state, heat flows, etc.) would equal the applied load vector {F<sup>a</sup>} (or at least to within some tolerance). None of
the intermediate solutions would be in equilibrium. </p><div class="figure"><a name="SH41g3dcmlg"></a><p class="title"><b>Figure&nbsp;14.10:&nbsp;&nbsp;Newton-Raphson Solution - Next Iteration</b></p><div class="figure-contents"><div><img src="graphics/gthy15-257.svg" alt="Newton-Raphson Solution - Next Iteration"></div></div></div><br class="figure-break"><p>If the analysis included path-dependent nonlinearities (such
as plasticity), then the solution process requires that some intermediate
steps be in equilibrium in order to correctly follow the load path.
This is accomplished effectively by specifying a step-by-step incremental
analysis; i.e., the final load vector {F<sup>a</sup>} is reached by applying the load in increments and performing the
Newton-Raphson iterations at each step: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq4overviewnov2101"></a><div><img src="graphics/thyeq4overviewnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;155)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>[K<sub>n,i</sub>] = tangent matrix for time step
n, iteration i </td></tr><tr><td>

<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eqafac555f-a912-4dc3-abc0-f3c0d474154d.svg"></span> = total applied force vector at time step
n </td></tr><tr><td>

<span class="inlineequation" style="&#xA;          vertical-align:-6.000000px"><img src="graphics/eq58ec0e86-df3e-4848-a510-293b759e20f4.svg"></span> = restoring
force vector for time step n, iteration i </td></tr></table><p>
</p><p>This process is the incremental Newton-Raphson procedure and
is shown in <a class="xref" href="thy_tool10.html#ACrre1d4leaf" title="Figure&nbsp;14.11:&nbsp;&nbsp;Incremental Newton-Raphson Procedure">Figure&nbsp;14.11:&nbsp;Incremental Newton-Raphson Procedure</a>. The Newton-Raphson procedure
guarantees convergence if and only if the solution at any iteration
{u<sub>i</sub>} is &#8220;near&#8221; the exact solution.
Therefore, even without a path-dependent nonlinearity, the incremental
approach (i.e., applying the loads in increments) is sometimes required
in order to obtain a solution corresponding to the final load level.</p><div class="figure"><a name="ACrre1d4leaf"></a><p class="title"><b>Figure&nbsp;14.11:&nbsp;&nbsp;Incremental Newton-Raphson Procedure</b></p><div class="figure-contents"><div><img src="graphics/gthy15-263.svg" alt="Incremental Newton-Raphson Procedure"></div></div></div><br class="figure-break"><p>When the stiffness matrix is updated every iteration (as indicated
in <a class="xref" href="thy_tool10.html#thyeq2overviewnov2101" title="(14&#8211;153)">Equation&nbsp;14&#8211;153</a> and <a class="xref" href="thy_tool10.html#thyeq4overviewnov2101" title="(14&#8211;155)">Equation&nbsp;14&#8211;155</a>) the process is termed a full Newton-Raphson
solution procedure ( <a href="../ans_cmd/Hlp_C_NROPT.html" class="olink"><span class="command"><strong>NROPT</strong></span></a>,FULL or <a href="../ans_cmd/Hlp_C_NROPT.html" class="olink"><span class="command"><strong>NROPT</strong></span></a>,UNSYM). Alternatively, the stiffness matrix could be updated less
frequently using the modified Newton-Raphson procedure (<a href="../ans_cmd/Hlp_C_NROPT.html" class="olink"><span class="command"><strong>NROPT</strong></span></a>,MODI). Specifically, for static or transient analyses, it would
be updated only during the first or second iteration of each substep,
respectively. Use of the initial-stiffness procedure (<a href="../ans_cmd/Hlp_C_NROPT.html" class="olink"><span class="command"><strong>NROPT</strong></span></a>,INIT) prevents any updating of the stiffness matrix, as shown in <a class="xref" href="thy_tool10.html#aI41g36emlg" title="Figure&nbsp;14.12:&nbsp;&nbsp;Initial-Stiffness Newton-Raphson">Figure&nbsp;14.12:&nbsp;Initial-Stiffness Newton-Raphson</a>. If a multistatus element is in the model,
however, it would be updated at iteration in which it changes status,
irrespective of the Newton-Raphson option. The modified and initial-stiffness
Newton-Raphson procedures converge more slowly than the full Newton-Raphson
procedure, but they require fewer matrix reformulations and inversions.
A few elements form an approximate tangent matrix so that the convergence
characteristics are somewhat different.</p><div class="figure"><a name="aI41g36emlg"></a><p class="title"><b>Figure&nbsp;14.12:&nbsp;&nbsp;Initial-Stiffness Newton-Raphson</b></p><div class="figure-contents"><div><img src="graphics/gthy15-264.svg" alt="Initial-Stiffness Newton-Raphson"></div></div></div><br class="figure-break"></div><div class="sect2" title="14.11.2.&nbsp;Convergence"><div class="titlepage"><div><div><h3 class="title"><a name="eltconverg"></a>14.11.2.&nbsp;Convergence</h3></div></div></div><a class="indexterm" name="d0e70560"></a><a class="indexterm" name="d0e70563"></a><a class="indexterm" name="d0e70566"></a><a class="indexterm" name="d0e70569"></a><a class="indexterm" name="d0e70572"></a><a class="indexterm" name="d0e70577"></a><a class="indexterm" name="d0e70582"></a><p>The iteration process described in the previous section continues
until convergence is achieved. The maximum number of allowed equilibrium
iterations (input on <a href="../ans_cmd/Hlp_C_NEQIT.html" class="olink"><span class="command"><strong>NEQIT</strong></span></a> command) are performed
in order to obtain convergence. </p><p>Convergence is assumed when </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eqe8b69e58-02fa-4c4d-bc77-ebcb17565647"></a><div><img src="graphics/eqe8b69e58-02fa-4c4d-bc77-ebcb17565647.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;156)</b></p></td></tr></table><p>and/or </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eqde7c1583-6236-4d9a-883c-3de385cd8af6"></a><div><img src="graphics/eqde7c1583-6236-4d9a-883c-3de385cd8af6.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;157)</b></p></td></tr></table><p>where {R} is the residual vector: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eq1dc4df3d-c6c8-41f0-a74b-d964f9d17ac3"></a><div><img src="graphics/eq1dc4df3d-c6c8-41f0-a74b-d964f9d17ac3.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;158)</b></p></td></tr></table><p>which is the right-hand side of the Newton-Raphson <a class="xref" href="thy_tool10.html#thyeq2overviewnov2101" title="(14&#8211;153)">Equation&nbsp;14&#8211;153</a>. {&#916;u<sub>i</sub>} is the DOF increment vector, &#949;<sub>R</sub> and &#949;<sub>u</sub> are tolerances (<a href="../ans_cmd/Hlp_C_CNVTOL.html" class="olink"><span class="command"><strong>CNVTOL</strong></span></a>,,,<em class="replaceable"><code>TOLER</code></em>) and R<sub>ref</sub> and u<sub>ref</sub> are reference values (<a href="../ans_cmd/Hlp_C_CNVTOL.html" class="olink"><span class="command"><strong>CNVTOL</strong></span></a>,,<em class="replaceable"><code>VALUE</code></em>). ||
<span class="inlineequation" style="&#xA;          vertical-align:0.000000px"><img src="graphics/eq7ff5a4ad-9ca3-4448-8482-2bb1329002f0.svg"></span>|| is a vector norm;
that is, a scalar measure of the magnitude of the vector (defined
below). </p><p>Convergence, therefore, is obtained when size of the residual
(disequilibrium) is less than a tolerance times a reference value
and/or when the size of the DOF increment is less than a tolerance
times a reference value. The default is to use out-of-balance convergence
checking only.  </p><p>There are three available norms (<a href="../ans_cmd/Hlp_C_CNVTOL.html" class="olink"><span class="command"><strong>CNVTOL</strong></span></a>,,,,<em class="replaceable"><code>NORM</code></em>) to choose from: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Infinite norm 
<span class="inlineequation" style="&#xA;          vertical-align:-8.000000px"><img src="graphics/eq762ac490-5672-4449-a4ba-6ff97590616e.svg"></span> </p></li><li class="listitem"><p>L1 norm 
<span class="inlineequation" style="&#xA;          vertical-align:-9.000000px"><img src="graphics/eqd5273c83-a906-4bde-bacb-64a6a727809d.svg"></span> </p></li><li class="listitem"><p>L2 norm 
<span class="inlineequation" style="&#xA;          vertical-align:-9.000000px"><img src="graphics/eq6a23c754-a3df-4151-aa63-d3cc5c185f4b.svg"></span> </p></li></ol></div><p>For DOF increment convergence, substitute &#916;u for R in
the above equations. The infinite norm is simply the maximum value
in the vector (maximum residual or maximum DOF increment), the L1
norm is the sum of the absolute value of the terms, and the L2 norm
is the square root of the sum of the squares (SRSS) value of the terms,
also called the Euclidean norm. The default is to use the L2 norm. </p><p>The default out-of-balance reference value R<sub>ref</sub> is ||{F<sup>a</sup>}||. For DOFs with imposed displacement
constraints, the default R<sub>ref</sub> value is {F<sup>nr</sup>} at those DOFs. </p><p>In the following cases, the default R<sub>ref</sub> value is the specified or default minimum reference value set via
the <a href="../ans_cmd/Hlp_C_CNVTOL.html" class="olink"><span class="command"><strong>CNVTOL</strong></span></a>,,,,,<em class="replaceable"><code>MINREF</code></em> command:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>For structural DOFs if R<sub>ref</sub> falls below 1.0E-2 (typically occurring in rigid-body motion analyses,
such as those involving stress-free rotation)</p></li><li class="listitem"><p>For thermal DOFs if R<sub>ref</sub> falls
below 1.0E-6</p></li><li class="listitem"><p>For EMAG DOFs if R<sub>ref</sub> falls
below 1.0E-12</p></li><li class="listitem"><p>For all other DOFs if R<sub>ref</sub> is
equal to 0.0 </p></li></ul></div><p>The default reference value u<sub>ref</sub> is ||{u}||. </p></div><div class="sect2" title="14.11.3.&nbsp;Predictor"><div class="titlepage"><div><div><h3 class="title"><a name="eltpredictor"></a>14.11.3.&nbsp;Predictor</h3></div></div></div><a class="indexterm" name="d0e70735"></a><a class="indexterm" name="d0e70738"></a><a class="indexterm" name="d0e70741"></a><p>The solution used for the start of each time step n {u<sub>n,0</sub>} is usually equal to the current DOF solution {u<sub>n -1</sub>}. The tangent matrix [K<sub>n,0</sub>] and restoring load {F<sup>n,0</sup>} are based
on this configuration. The predictor option (<a href="../ans_cmd/Hlp_C_PRED.html" class="olink"><span class="command"><strong>PRED</strong></span></a> command) extrapolates the DOF solution using the previous history
in order to take a better guess at the next solution. </p><p>In static analyses, the prediction is based on the displacement
increments accumulated over the previous time step, factored by the
time-step size: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eq4eee1640-6b87-46c2-b011-2a2b73568f13"></a><div><img src="graphics/eq4eee1640-6b87-46c2-b011-2a2b73568f13.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;159)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>{&#916;u<sub>n</sub>} = displacement increment
accumulated over the previous time step </td></tr><tr><td>n = current time step </td></tr></table><p>
</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eq0ab3bde1-f293-47e1-a8d0-17d4475aa0fb"></a><div><img src="graphics/eq0ab3bde1-f293-47e1-a8d0-17d4475aa0fb.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;160)</b></p></td></tr></table><p>and &#946; is defined as: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eq4e861e85-bac7-46e1-886e-3878288f5cb5"></a><div><img src="graphics/eq4e861e85-bac7-46e1-886e-3878288f5cb5.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;161)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>&#916;t<sub>n</sub> = current time-step size </td></tr><tr><td>&#916;t<sub>n-</sub>1 = previous time-step size </td></tr></table><p>
</p><p>&#946; is not allowed to be greater than 5. </p><p>In transient analyses, the prediction is based on the current
velocities and accelerations using the Newmark formulas for structural
DOFs: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eq5ad05948-770e-40a6-a7a9-98e1c5cbb24d"></a><div><img src="graphics/eq5ad05948-770e-40a6-a7a9-98e1c5cbb24d.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;162)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>

<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq52b8a16d-da81-4c9c-a1de-0ac928ad7b9a.svg"></span> = current displacements, velocities and
accelerations </td></tr><tr><td>&#916;t<sub>n</sub> = current time-step size </td></tr><tr><td>&#945; = Newmark parameter (input on <a href="../ans_cmd/Hlp_C_TINTP.html" class="olink"><span class="command"><strong>TINTP</strong></span></a> command) </td></tr></table><p>
</p><p>For thermal, magnetic and other first order systems, the prediction
is based on the trapezoidal formula: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eq82c1f14e-bf29-468e-993d-737718b7c95e"></a><div><img src="graphics/eq82c1f14e-bf29-468e-993d-737718b7c95e.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;163)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>{u<sub>n - 1</sub>} = current temperatures (or
magnetic potentials) </td></tr><tr><td>

<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq0c6b6f7d-0bad-45e3-ab15-af1b772e3f21.svg"></span> = current rates of these
quantities </td></tr><tr><td>&#952; = trapezoidal time integration parameter (input on <a href="../ans_cmd/Hlp_C_TINTP.html" class="olink"><span class="command"><strong>TINTP</strong></span></a> command) </td></tr></table><p>
</p><p>See <a class="xref" href="thy_anproc2.html" title="15.2.&nbsp;Transient Analysis">Transient Analysis</a> for more details on the transient
procedures. </p><p>The subsequent equilibrium iterations provide DOF increments
{&#916;u} with respect to the predicted DOF value {u<sub>n,0</sub>}, hence this is a predictor-corrector algorithm. </p></div><div class="sect2" title="14.11.4.&nbsp;Adaptive Descent"><div class="titlepage"><div><div><h3 class="title"><a name="eltadaptive"></a>14.11.4.&nbsp;Adaptive Descent</h3></div></div></div><a class="indexterm" name="d0e70864"></a><a class="indexterm" name="d0e70867"></a><a class="indexterm" name="d0e70870"></a><a class="indexterm" name="d0e70873"></a><a class="indexterm" name="d0e70878"></a><a class="indexterm" name="d0e70881"></a><p>Adaptive descent (<span class="italic"><em>Adptky</em></span> on
the <a href="../ans_cmd/Hlp_C_NROPT.html" class="olink"><span class="command"><strong>NROPT</strong></span></a> command) is a technique which switches
to a &#8220;stiffer&#8221; matrix if convergence difficulties are
encountered, and switches back to the full tangent as the solution
convergences, resulting in the desired rapid convergence rate (Eggert(<a class="xref" href="thy_biblio.html#ibZpf28cmlg" title="&#34;An Adaptive Descent Method for Nonlinear Viscoplasticity">[152]</a>)). </p><p>The matrix used in the Newton-Raphson equation (<a class="xref" href="thy_tool10.html#thyeq2overviewnov2101" title="(14&#8211;153)">Equation&nbsp;14&#8211;153</a>) is defined as the sum of two matrices: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="eq306afa97-5c87-45f1-bd36-c1b317dc67d9"></a><div><img src="graphics/eq306afa97-5c87-45f1-bd36-c1b317dc67d9.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;164)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>[K<sup>S</sup>] = secant (or most stable)
matrix </td></tr><tr><td>[K<sup>T</sup>] = tangent matrix </td></tr><tr><td>&#958; = descent parameter </td></tr></table><p>
</p><p>The program adaptively adjusts the descent parameter (&#958;)
during the equilibrium iterations as follows: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Start each substep using the tangent matrix (&#958;
= 0). </p></li><li class="listitem"><p>Monitor the change in the residual ||{R}||<sub>2</sub> over the equilibrium iterations: </p><p>If it
increases (indicating possible divergence): </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>remove the current solution if &#958; &lt; 1, reset &#958;
to 1 and redo the iteration using the secant matrix </p></li><li class="listitem"><p>if already at &#958; = 1, continue iterating </p></li></ul></div><p>If it decreases (indicating converging solution): </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If &#958; = 1 (secant matrix) and the residual has
decreased for three iterations in a row (or 2 if &#958; was increased
to 1 during the equilibrium iteration process by (a.) above), then
reduce &#958; by a factor of 1/4 (set it to 0.25) and continue iterating. </p></li><li class="listitem"><p>If the &#958; &lt; 1, decrease it again by a factor
of 1/4 and continue iterating. Once &#958; is below 0.0156, set it
to 0.0 (use the tangent matrix). </p></li></ul></div></li><li class="listitem"><p>If a negative pivot message is encountered (indicating
an ill-conditioned matrix): </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If &#958; &lt; 1, remove the current solution, reset &#958;
= 1 and redo the iteration using the secant matrix. </p></li><li class="listitem"><p>If &#958; = 1, bisect the time step if automatic time
stepping is active, otherwise terminate the execution. </p></li></ul></div></li></ol></div><p>The nonlinearities which make use of adaptive descent (that is, they form a secant matrix if
   &#958; &gt; 0) include: plasticity, contact, stress stiffness with large strain, and nonlinear
   magnetics using the scalar potential formulation. Adaptive descent is used by default in these
   cases unless the line search or arc-length options are on. It is only available with full
   Newton-Raphson, where the matrix is updated every iteration. Full Newton-Raphson is also the
   default for plasticity, contact and large strain nonlinearities. </p></div><div class="sect2" title="14.11.5.&nbsp;Line Search"><div class="titlepage"><div><div><h3 class="title"><a name="eltlinesearc"></a>14.11.5.&nbsp;Line Search</h3></div></div></div><a class="indexterm" name="d0e70965"></a><a class="indexterm" name="d0e70968"></a><p>The line search option (accessed with <a href="../ans_cmd/Hlp_C_LNSRCH.html" class="olink"><span class="command"><strong>LNSRCH</strong></span></a> command) attempts to improve a Newton-Raphson solution {&#916;u<sub>i</sub>} by scaling the solution vector by a scalar value termed
the line search parameter. </p><p>Consider <a class="xref" href="thy_tool10.html#thyeq3overviewnov2101" title="(14&#8211;154)">Equation&nbsp;14&#8211;154</a> again: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq1linenov2101"></a><div><img src="graphics/thyeq1linenov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;165)</b></p></td></tr></table><p>In some solution situations, the use of the full {&#916;u<sub>i</sub>} leads to solution instabilities. Hence, if the line
search option is used, <a class="xref" href="thy_tool10.html#thyeq1linenov2101" title="(14&#8211;165)">Equation&nbsp;14&#8211;165</a> is modified
to be: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq2linenov2101"></a><div><img src="graphics/thyeq2linenov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;166)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>s = line search parameter, 0.05 &lt; s &lt; 1.0 </td></tr></table><p>
</p><p>s is automatically determined by minimizing the energy of the
system, which reduces to finding the zero of the nonlinear equation: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq3linenov2101"></a><div><img src="graphics/thyeq3linenov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;167)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>g<sub>s</sub> = gradient of the potential energy
with respect to s </td></tr></table><p>
</p><p>An iterative solution scheme based on regula falsi is used to
solve <a class="xref" href="thy_tool10.html#thyeq3linenov2101" title="(14&#8211;167)">Equation&nbsp;14&#8211;167</a> (Schweizerhof and Wriggers(<a class="xref" href="thy_biblio.html#aiZpf328mlg" title="&#34;Consistent Linearization for Path Following Methods in Nonlinear FE Analysis&#34;">[153]</a>)). Iterations are continued until either: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>g<sub>s</sub> is less than 0.5 g<sub>o</sub>, where g<sub>o</sub> is the value of <a class="xref" href="thy_tool10.html#thyeq3linenov2101" title="(14&#8211;167)">Equation&nbsp;14&#8211;167</a> at s = 0.0 (that is, using 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq7ef4bddb-f782-469d-ad98-a2e8f4a9309c.svg"></span> for {F<sup>nr</sup> (s{&#916;u})}). </p></li><li class="listitem"><p>g<sub>s</sub> is not changing significantly
between iterations. </p></li><li class="listitem"><p>Six iterations have been performed. </p></li></ol></div><p>If g<sub>o</sub> &gt; 0.0, no iterations are performed
and s is set to 1.0. s is not allowed below 0.05. </p><p>The scaled solution {&#916;u<sub>i</sub>} is used
to update the current DOF values {u<sub>i+1</sub>} in <a class="xref" href="thy_tool10.html#thyeq3overviewnov2101" title="(14&#8211;154)">Equation&nbsp;14&#8211;154</a> and the next equilibrium iteration
is performed. </p></div><div class="sect2" title="14.11.6.&nbsp;Arc-Length Method"><div class="titlepage"><div><div><h3 class="title"><a name="eltarclength"></a>14.11.6.&nbsp;Arc-Length Method</h3></div></div></div><a class="indexterm" name="d0e71071"></a><a class="indexterm" name="d0e71074"></a><a class="indexterm" name="d0e71077"></a><a class="indexterm" name="d0e71080"></a><p>The arc-length method (accessed with <a href="../ans_cmd/Hlp_C_ARCLEN.html" class="olink"><span class="command"><strong>ARCLEN</strong></span></a>,ON) is suitable for nonlinear static equilibrium solutions of unstable
problems. </p><p>Application of the arc-length method involves the tracing of
a complex path in the load-displacement response into the buckling/post
buckling regimes. The arc-length method uses Crisfield&#8217;s method
as describe in (<a class="xref" href="thy_biblio.html#Ymyqj371jw" title="&#8220;A fast and incremental/iterative solution procedure that handles snap-through&#8221;">[175]</a>) to prevent any fluctuation
of the step size during equilibrium iterations. It is assumed that
all load magnitudes can be controlled by a single scalar parameter
(that is, the total load factor). </p><p>An unsmooth or discontinuous load-displacement response, which
is sometimes seen in contact analyses and elastic-perfectly plastic
analyses, cannot be traced effectively by the arc-length solution
method. </p><p>Mathematically, the arc-length method can be viewed as the trace
of a single equilibrium curve in a space spanned by the nodal displacement
variables and the total load factor. Therefore, all options of the
Newton-Raphson method are still the basic method for the arc-length
solution. As the displacement vectors and the scalar load factor are
treated as unknowns, the arc-length method itself is an automatic
load step method; therefore, <a href="../ans_cmd/Hlp_C_AUTOTS.html" class="olink"><span class="command"><strong>AUTOTS</strong></span></a>,ON is not needed. </p><p>For problems with sharp turns in the load-displacement curve
or with path-dependent materials, it is necessary to limit the initial
arc-length radius (<a href="../ans_cmd/Hlp_C_NSUBST.html" class="olink"><span class="command"><strong>NSUBST</strong></span></a>) and the arc-length radius
augmentation (via the <em class="replaceable"><code>MAXARC</code></em> argument of
the <a href="../ans_cmd/Hlp_C_ARCLEN.html" class="olink"><span class="command"><strong>ARCLEN</strong></span></a> command). During the solution, the arc-length
method will vary the arc-length radius at each arc-length substep
according to the degree of nonlinearity that is involved. The range
of variation of the arc-length radius is limited by the maximum and
minimum multipliers (<em class="replaceable"><code>MAXARC</code></em> and <em class="replaceable"><code>MINARC</code></em> on the <a href="../ans_cmd/Hlp_C_ARCLEN.html" class="olink"><span class="command"><strong>ARCLEN</strong></span></a> command). </p><p>In the arc-length procedure, <a class="xref" href="thy_tool10.html#thyeq2overviewnov2101" title="(14&#8211;153)">Equation&nbsp;14&#8211;153</a> is recast and associated with the total load factor &#955;: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq1arcnov2101"></a><div><img src="graphics/thyeq1arcnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;168)</b></p></td></tr></table><p>
<a class="xref" href="thy_tool10.html#CZzqj185jw" title="Figure&nbsp;14.13:&nbsp;&nbsp;Arc-Length Approach with Full Newton-Raphson Method">Figure&nbsp;14.13:&nbsp;Arc-Length Approach with Full Newton-Raphson Method</a> is a graphical representation of
the arc-length method. Writing the proportional loading factor &#955;
in an incremental form at substep n and iteration i yields: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq2arcnov2101"></a><div><img src="graphics/thyeq2arcnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;169)</b></p></td></tr></table><div class="figure"><a name="CZzqj185jw"></a><p class="title"><b>Figure&nbsp;14.13:&nbsp;&nbsp;Arc-Length Approach with Full Newton-Raphson Method</b></p><div class="figure-contents"><div><img src="graphics/gthy15-291.svg" alt="Arc-Length Approach with Full Newton-Raphson Method"></div></div></div><br class="figure-break"><p>Following <a class="xref" href="thy_tool10.html#thyeq2arcnov2101" title="(14&#8211;169)">Equation&nbsp;14&#8211;169</a>, the incremental
displacement {&#916;u<sub>i</sub>} can be written in
two parts: </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq3arcnov2101"></a><div><img src="graphics/thyeq3arcnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;170)</b></p></td></tr></table><p>where:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq4arcnov2101"></a><div><img src="graphics/thyeq4arcnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;171)</b></p></td></tr></table><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq5arcnov2101"></a><div><img src="graphics/thyeq5arcnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;172)</b></p></td></tr></table><p>In each arc-length iteration, it is necessary to use <a class="xref" href="thy_tool10.html#thyeq4arcnov2101" title="(14&#8211;171)">Equation&nbsp;14&#8211;171</a> and <a class="xref" href="thy_tool10.html#thyeq5arcnov2101" title="(14&#8211;172)">Equation&nbsp;14&#8211;172</a> to solve for 
<span class="inlineequation" style="&#xA;          vertical-align:-6.000000px"><img src="graphics/eq55450bb1-a6a2-44fb-a275-4f0f86c61938.svg"></span> and 
<span class="inlineequation" style="&#xA;          vertical-align:-6.000000px"><img src="graphics/eq633c8906-fabf-4db5-b5c6-cce874226a44.svg"></span>.</p><p>We can define one vector between the previous equilibrium point
and a point determined in iteration i by:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq6arcnov2101"></a><div><img src="graphics/thyeq6arcnov2101.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;173)</b></p></td></tr></table><p>where: </p><table border="0" summary="Simple list" class="simplelist"><tr><td>{&#916;u<sub>n</sub>} = the displacement increment
accumulated over the current time step</td></tr><tr><td>&#946; = the scaling vector for unit displacements</td></tr></table><p>
</p><p>The norm of this vector is:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq7arc"></a><div><img src="graphics/thyeq7arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;174)</b></p></td></tr></table><p>At iteration i+1, the vector becomes:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq8arc"></a><div><img src="graphics/thyeq8arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;175)</b></p></td></tr></table><p>Crisfield&#8217;s method assumes that the norm of the vector
is constant along the equilibrium iterations, that is:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="theq9arc"></a><div><img src="graphics/theq9arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;176)</b></p></td></tr></table><p>Substituting <a class="xref" href="thy_tool10.html#thyeq6arcnov2101" title="(14&#8211;173)">Equation&nbsp;14&#8211;173</a> and <a class="xref" href="thy_tool10.html#thyeq8arc" title="(14&#8211;175)">Equation&nbsp;14&#8211;175</a> and using <a class="xref" href="thy_tool10.html#thyeq3arcnov2101" title="(14&#8211;170)">Equation&nbsp;14&#8211;170</a>,
the following quadratic equation results:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq10arc"></a><div><img src="graphics/thyeq10arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;177)</b></p></td></tr></table><p>where:</p><div class="informalequation"><a name="eq76f9a1be-9d35-4665-ba8d-0aa025167a40"></a><div><img src="graphics/eq76f9a1be-9d35-4665-ba8d-0aa025167a40.svg"></div></div><p>This system has two real roots, &#916;&#955;<sup>(1)</sup> and &#916;&#955;<sup>(2)</sup>, which both satisfy
the constant arc-length radius.</p><p>For each of these roots, we can define the angle between vector
t<sub>n-1</sub> in the previously converged substep, and
vector t<sub>i+1</sub> in the current substep. This angle
may be obtained from:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq11arc"></a><div><img src="graphics/thyeq11arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;178)</b></p></td></tr></table><p>To move the equilibrium path forward, we choose the route for
which the cosine of the associated angle is the closest to 1.</p><p>Finally, the solution vectors are updated according to (see <a class="xref" href="thy_tool10.html#CZzqj185jw" title="Figure&nbsp;14.13:&nbsp;&nbsp;Arc-Length Approach with Full Newton-Raphson Method">Figure&nbsp;14.13:&nbsp;Arc-Length Approach with Full Newton-Raphson Method</a>): </p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq12arc"></a><div><img src="graphics/thyeq12arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;179)</b></p></td></tr></table><p>and</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq13arc"></a><div><img src="graphics/thyeq13arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;180)</b></p></td></tr></table><p>Values of &#955;<sub>n</sub> and &#916;&#955; are
available in POST26 corresponding to labels ALLF and ALDLF, respectively,
on the <a href="../ans_cmd/Hlp_C_SOLU.html" class="olink"><span class="command"><strong>SOLU</strong></span></a> command. The normalized arc-length
radius label ARCL (also on <a href="../ans_cmd/Hlp_C_SOLU.html" class="olink"><span class="command"><strong>SOLU</strong></span></a>) corresponds to
value 
<span class="inlineequation" style="&#xA;          vertical-align:-8.000000px"><img src="graphics/eq3f27d472-510c-4091-ade3-7a4e9d87078a.svg"></span>, where 
<span class="inlineequation" style="&#xA;          vertical-align:-5.000000px"><img src="graphics/eq421afe98-a3f8-472d-949b-0eccd74b5dca.svg"></span> is the
initial arc-length radius defined through <a class="xref" href="thy_tool10.html#thyeq7arc" title="(14&#8211;174)">Equation&nbsp;14&#8211;174</a> and <a class="xref" href="thy_tool10.html#thyeq14arc" title="(14&#8211;181)">Equation&nbsp;14&#8211;181</a> (an arc-length radius at the first
iteration of the first substep). </p><p>Defining K<sub>0</sub> as the initial tangent matrix,
F<sup>a</sup> as the full external load, and &#955;<sub>0</sub> as the initial load factor (specified using the <a href="../ans_cmd/Hlp_C_NSUBST.html" class="olink"><span class="command"><strong>NSUBST</strong></span></a> command), the initial arc-length radius t<sub>0</sub> is determined by:</p><table width="100%" class="equation"><colgroup><col width="95%" align="center"><col width="5%" align="right"></colgroup><tr><td align="center"><a name="thyeq14arc"></a><div><img src="graphics/thyeq14arc.svg"></div></td><td nowrap="yes" align="right" valign="middle"><p class="title"><b>(14&#8211;181)</b></p></td></tr></table><p>where:</p><div class="informalequation"><a name="eq5922aff3-1946-4d14-a748-346dc6fe867a"></a><div><img src="graphics/eq5922aff3-1946-4d14-a748-346dc6fe867a.svg"></div></div><p>The factors <em class="replaceable"><code>MAXARC</code></em> and <em class="replaceable"><code>MINARC</code></em> (input on the <a href="../ans_cmd/Hlp_C_ARCLEN.html" class="olink"><span class="command"><strong>ARCLEN</strong></span></a> command)
are used to define the limits of the arc-length radius by the following
formulas:</p><div class="informalexample"><p>t<sub>MAX</sub> = <em class="replaceable"><code>MAXARC</code></em> * t<sub>0</sub>
</p></div><p>
</p><div class="informalexample"><p>t<sub>MIN</sub> = <em class="replaceable"><code>MINARC</code></em> * t<sub>0</sub>
</p></div><p>
</p></div></div><hr><p class="legalfooter"><small><i>Release 18.2 - &copy; ANSYS, Inc. All rights reserved.</i></small></p></body></html>